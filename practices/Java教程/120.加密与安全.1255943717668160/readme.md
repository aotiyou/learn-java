### 编码
ASCII就是一种编码，最多只能有127个字符U
Unicode编码
UTF-8编码

URL编码：浏览器发送数据给服务器时使用的编码

Base64编码：对二进制数据进行编码，表示成文本格式
原理：把3字节的二进制数据按6bit一组，用4个int证书表示，然后查表，把int证书用索引对应到字符，得到编码后的字符串

### 哈希算法
重要特点：
* 相同的输入一定得到相同的输出
* 不同的输入大概率得到不同的输出

目的：
**就是为了验证原始数据是否被篡改**

哈希碰撞：
**两个不同的输入得到了相同的输出**
**无线的输入集合映射到一个有限的输出集合，必然会产生碰撞**

安全的哈希算法必须满足：
* 碰撞概率低
* 不能猜测输出

常见的哈希算法：

| 算法 | 输出长度（位） | 输出长度（字节） |
| ---- | -------------- | ---------------- |
| MD5    | 128bits | 16bytes  |
| SHA-1  | 160bits | 20bytes  |
| RipeMD-160 | 160bits | 20bytes |
| SHA-256 | 256bits | 32bytes |
| SHA-512 | 512bits | 64bytes |

用途：
* 防篡改
* 存储用户口令（注意防止彩虹表攻击）
防止彩虹表攻击：
方法：每个口令额外添加随机数，这种方法称为盐(salt)

### BouncyCastle
开源的第三方算法提供商
使用第三方算法前需要通过Security.addProvider()注册

### Hmac算法
全称 Hash-based Message Authentication Code
Hmac是一种基于秘钥的消息认证码算法

使用HmacMD5而不是用MD5加salt，有以下好处：
* HmacMD5使用的key长度是64字节，更安全
* Hmac是标准算法，同样适用于SHA-1等其他哈希算法
* Hmac输出和原有的哈希算法长度一致

### 对称加密算法

常用的对称加密算法

|  算法  |  秘钥长度  |  工作模式  |  填充模式  |
| ---- | -------------- | ---------------- |
| DES | 56/64 | ECB/CBC/PCBC/CTR/... | NoPadding/PKCS5Padding/... |
| AES | 128/192/256 | ECB/CBC/PBCB/CTR/... | NoPadding/PKCS5Padding/PKCS7Padding/... |
| IDEA | 128 | ECB | PKCS5Padding/PKCS7Padding/... |

秘钥长度直接决定加密强度
工作模式：对称加密算法的参数
填充模式：对称加密算法的格式选择

对称加密编写代码步骤：
* 1.根据算法名称/工作模式/填充模式获取Cipher实例
* 2.根据算法名称初始化一个SecretKey实例，秘钥必须是指定长度；
* 3.使用SecretKey初始化Cipher实例，并设置加密或解密模式
* 4.传入明文或密文，获取密文或明文

ECB模式是最简单的AES加密模式，它只需要一个固定长度的秘钥，
固定的明文会生成固定的密文，这种一对一的加密方式会导致安全性降低，
更好的方式是通过CBC模式，它需要一个随机数作为IV参数，这样对于同一份明文，每次生成的密文都不同。

### 口令密码算法

实际上用户输入的口令并不能直接作为AES的秘钥进行加密（除非长度恰好是128/192/256位），
并且用户输入的口令一般都有规律，安全性远远不如安全随机数产生的随机口令。
因此，用户输入的口令，通常还需要使用PBE算法，采用随机数杂凑计算出真正的秘钥，再进行加密。

PBE (Password Based Encryption)
PBE的作用：
就是把用户输入的口令和一个安全随机的口令采用杂凑后计算出真正的秘钥。

### 秘钥交换算法

如何在不安全的信道上安全地传输秘钥？
使用秘钥交换算法即DH算法：Diffie-Hellman算法

DH算法解决了秘钥在双方不直接传递秘钥的情况下完成秘钥交换，这个神奇的交换原理完全由数学理论支持。

DH算法交换秘钥的步骤：
1. 甲： 素数p：509 底数g：5   随机数a：123 计算 A = g^a mod p 结果215
      发送 p=509 g=5 A=215
2. 乙： 素数p：509 底数g：5   随机数b：456 计算 B = g^b mod p 结果181
       素数p：509 底数A：215 随机数b：456 计算 C = A^b mod p 结果121
      发送 B=181
3. 甲： 素数p：509 底数B：181 随机数a：123 计算 C = B^a mod p 结果121 

DH算法是一个秘钥协商算法，双方最终协商出一个共同的秘钥，而这个秘钥不会在网络传输。

如果我们把a看成甲的私钥，A看成甲的公钥，b看成乙的私钥，B看成乙的公钥，DH算法的本质就是双方各自生成自己的私钥和公钥，
私钥仅对自己可见，然后交换公钥，并根据自己的私钥和对方的公钥，生成最终的秘钥secretKey，
DH算法通过数学定律保证了双方各自计算出的secretKey是相同的。

但是DH算法未解决中间人攻击，即甲乙双方并不能确保与自己通信的是否真的是对方。

### 非对称加密算法

非对称加密就是加密和解密使用的不是相同的秘钥：只有同一个公钥-私钥对才能正常加解密。

非对称加密的缺点：运算速度非常慢，比对称加密要慢很多。

在实际应用的时候，非对称加密总是和对称加密一起使用。假设小明需要给小红传输加密文件，他俩首先交换了各自的公钥，然后：
1.小红生成一个随机的AES口令，然后用小红的公钥通过RSA加密这个口令，并发给小红；
2.小红用自己的RSA私钥解密得到AES口令；
3.双方使用这个共享的AES口令用AES加密通信。

不能防止中间人攻击

### 签名算法

公钥加密，私钥解密。

私钥加密得到的密文实际上就是数字签名，要验证这个签名是否正确，只能用私钥持有者的公钥进行解密验证。
使用数字签名的目的是问了确认某个信息缺失是由某个发送发发送的，任何人都不可能伪造信息，并且，发送方也不能抵赖。

在实际应用的时候，签名实际上并不是针对原始信息，而是针对原始消息的哈希进行签名，即：
`signature = encrypt(privateKey, sha256(message))`
对签名进行验证实际上就是用公钥解密：
`hash = decrypt(publicKey, signature)`
然后把解密后的哈希与原始消息的哈希进行对比。

私钥相当于用户身份；公钥来给外部验证用户身份。

常见的数字签名算法有：
* MD5withRSA
* SHA1withRSA
* SHA256withRSA

数字签名用于：
* 防止伪造
* 防止抵赖
* 检测篡改

### 数字证书

摘要算法用来确保数据没有被篡改
非对称加密算法可以对数据今进行加解密
签名算法可以确保数据完整性和抗否认性
把这些算法集合到一起，并搞一套完善的标准，这就是数字证书。

数字证书可以防止中间人攻击，因为它采用链式签名认证，即通过根证书（Root CA）去签名下一级证书，这样层层签名，直到最终的用户证书。
而Root CA证书内置于操作系统中，所以，任何经过CA认证的数字证书否可以对其本身进行校验，确保证书本身不是伪造的。

以HTTPS协议为例，浏览器和服务器建立安全连接的步骤如下：
1.浏览器向服务器发起请求，服务器向浏览器发送自己的数字证书；
2.浏览器用操作系统内置的Root CA来验证服务器的证书是否有效，如果有效，就使用该证书加密一个随机的AES口令并发送给服务器；
3.服务器用自己的私钥解密获得AES口令，并在后续通讯中使用AES加密。









​    

​    
