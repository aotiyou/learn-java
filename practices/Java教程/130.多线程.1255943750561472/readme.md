操作系统执行多任务实际上就是让CPU对多个任务轮流交替执行。

进程和线程的关系：一个进程可以包含一个或多个线程，但至少会有一个线程。

实现多任务的方法，有以下几种：
* 多线程模式（每个进程只有一个线程）
* 多线程模式（一个进程有多个线程）
* 多进程+多线程模式（复杂度最高）

进程 vs 线程

和多线程相比，多进程的缺点在于：
* 创建进程比创建线程开销大，尤其是在windows系统上
* 进程间通信比线程间通信要慢，因为线程间通信就是读写同一个变量，速度很快。

多进程的优点：
* 多进程稳定性比多线程高。

多线程

一个Java程序实际上就是一个JVM进程，JVM进程用一个主线程来执行main()方法，在main()方法内部，我们又可以启动多个线程。

对于Java程序来说，多任务，实际上就是如何使用多线程实现多任务。

java多线程编程特点：
* 多线程模型是Java程序最基本的并发模型
* 后续读写网络、数据库、Web开发等都依赖Java多线程模型

### 创建新线程

* 从Thread继承，覆写run()方法
* 实现Runnable，覆写run()方法

**注意：直接调用Thread实例的 run()方法是无效的，必须调用Thread实例的start()方法才能启动新线程**
native修饰符表示这个方法是有JVM虚拟机内部的C代码实现的，不是由Java代码实现的。

线程的优先级

优先级高的线程被操作系统调度的优先级较高，
操作系统对高优先级线程可能调度更频繁，但我们决不能通过设置优先级来确保高优先级的线程一定会先执行。
线程调用由操作系统决定，程序本身无法决定调用顺序。

### 线程的状态

Java线程的状态：
* New：新创建的线程，尚未执行；
* Runnable：运行中的线程，正在执行run()方法的Java代码
* Blocked：运行中的线程，因为某些操作被阻塞而挂起
* Waiting：运行中的线程，因为某些操作在等待中
* Timed Waiting：运行中的线程，因为执行sleep()方法正在计时等待
* Terminated：线程已终止，因为run()方法执行完毕

线程终止的原因：
* 线程正常终止：run()方法执行到return语句返回；
* 线程意外终止：run()方法因为未捕获的异常导致线程终止；
* 对某个下城的Thread实例调用stop()方法强制终止(强烈不推荐使用)

通过对另一个线程对象调用join()方法可以等待其执行结果；
可以指定等待时间，超过等待时间线程人谈没有结束就不再等待；
对已经运行结束的线程调用join()方法会立刻返回。

### 中断线程

中断线程就是其他线程给该线程发一个信号，该线程收到信号后结束执行run()方法，使得自身线程能立刻结束运行。

中断一个线程非常简单，只需要在其他线程中对目标线程调用interrupt()方法，
目标线程需要反复检测自身状态是否是interrupted状态，如果是，就立刻结束运行。

线程间共享变量需要使用volatile关键字标记，确保每个线程都能读取到更新后的变量值。

为什么对线程间共享的变量用关键字volatile声明？
这涉及到Java的内存模型。在Java虚拟机中，变量的值保存在主内存中，
但是，当线程访问变量时，它会先获取一个副本，并保存在自己的工作内存中。
如果线程修改了变量的值，虚拟机会在某个时刻把修改后的值回写到主内存，但是，这个时间是不确定的！
这会导致一个线程更新了某个变量，另一个线程读取的值可能还是更新前的。

volatile关键字的目的是告诉虚拟机：
* 每次访问变量后，总是获取主内存的最新值；
* 每次修改变量后，立刻回写到主内存。

volatile关键字解决的是可见性问题：当一个线程修改了某个共享变量的值，其他线程能够立刻看到修改后的值。

x86架构，ARM架构

对目标线程调用interrupt()方法可以请求中断一个线程，目标线程通过检测isInterrupted()标志获取自身是否已中断。
如果目标线程处于等待状态，该线程会捕获到InterruptedException;

目标线程检测到isInterrupted()为true()或者捕获了InterruptedException都应该立刻结束自身线程；

通过标志位判断需要正确使用volatile关键字；

volatile关键字解决了共享变量在线程间的可见性问题。

### 守护线程

如果有一个线程没有退出，JVM进程就不会退出。所以，必须保证所有线程都能及时结束。

有一种线程的目的就是无限循环，如果这个线程不结束，JVM进程就无法结束。问题是，由谁负责结束这个线程？
然而这类线程经常没有负责人来负责结束它们。但是，当其他线程结束时，JVM进程又必须要结束，怎么办？
答案是使用守护线程(Daemon Thread)。

守护线程是指为其他线程服务的线程。在JVM中，所有非守护线程都执行完毕后，无论有没有守护线程，虚拟机都会自动退出。
因此，JVM退出时，不必关系守护线程是否已结束。

创建守护线程

在调用start()方法前，代用setDaemon(true)把该线程标记为守护线程。

在守护线程中，编写代码要注意：守护现场不能持有任何需要关闭的资源，
例如打开文件等，因为虚拟机退出时，守护线程没有任何机会来关闭文件，这会导致数据丢失。

### 线程同步





